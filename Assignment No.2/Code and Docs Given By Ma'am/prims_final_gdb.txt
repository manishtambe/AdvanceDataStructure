/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/

import java.util.*;


class Graph
{
   
   private static int infinite = 9999999;

   int[][]  LinkCost;
   int      NNodes;

   /* -------------------------------

      Construct a graph of N nodes
      ------------------------------- */
   Graph(int[][] mat)
   {
      int i, j;

      NNodes = mat.length;

      LinkCost = new int[NNodes][NNodes];

      for ( i=0; i < NNodes; i++)		//copy mat to Linkcost and replace 0 with infinite
      {
         for ( j=0; j < NNodes; j++)
         {
            LinkCost[i][j] = mat[i][j];

            if ( LinkCost[i][j] == 0 )
               LinkCost[i][j] = infinite;
         }
      }

      for ( i=0; i < NNodes; i++)
      {
         for ( j=0; j < NNodes; j++)
            if ( LinkCost[i][j] < infinite )
               System.out.print( " " + LinkCost[i][j] + " " );
            else
               System.out.print(" * " );

         System.out.println();
      }
   }


      public void Prim( )
   {
      int i, j, k, x, y;

      boolean[] Reached = new boolean[NNodes];	// Reach/unreach nodes
      int[] predNode = new int[NNodes];		// Remember min cost edge

      // Start at a vertex, I picked the start node = 0

      Reached[0] = true;

      // Other vertices are not reached 

      for ( k = 1; k < NNodes; k++ )
      {
         Reached[k] = false;
      }

      predNode[0] = 0;      // No edge for node 0

      printReachSet( Reached );

      /* =====================================================
         UnReachSet will decreas by 1 node in each iteration
	 There are NNodes-1 unreached nodes; so we can loop
	 NNodes-1 times and UnReachSet will become empty !
	 =====================================================  */
      for (k = 1; k < NNodes; k++)
      {
         /* ================================================================
	    Find min. cost link between: reached node ---> unreached node
            ================================================================ */
         x = y = 0;

         for ( i = 0; i < NNodes; i++ )
            for ( j = 0; j < NNodes; j++ )
            {
                if ( Reached[i] && !Reached[j] &&
                     LinkCost[i][j] < LinkCost[x][y] )
                {
		   x = i;
		   y = j;
                }
            }

         System.out.println("Min cost edge: (" +     //Print in this format Min cost edge: (0,3)cost = 2
				+ x + "," + 
				+ y + ")" +
				"cost = " + LinkCost[x][y]);

         /* =================================
	    Add e (x,y) to Spanning tree
            ================================= */
         predNode[y] = x;          // Record the min cost link //Previous vertex of y is x

	 /* ==========================================
	    ReachSet = ReachSet union {y}
	    UnReachSet = UnReachSet - {y}
	    ========================================== */
         Reached[y] = true;

         printReachSet( Reached );     // Print state....
         System.out.println();
      }  //End of for loop. Get repeated for n-a times

      printMinCostEdges( predNode );
   }

   void printMinCostEdges( int[] a )
   {
      for ( int i = 0; i < NNodes; i++ )
          System.out.println( a[i] + " --> " + i );
   }

   void printReachSet(boolean[] Reached )		//Print reached vertices
   {
      System.out.print("ReachSet = ");
      for (int i = 0; i < Reached.length; i++ )
         if ( Reached[i] )
           System.out.print( i + " ");
      System.out.println();
   }

}

public class Main
{

   public static void main(String[] args)
   {

                  
// ===================================================
      int[][] conn = {{0,3,0,2,0,0,0,0,4},  // 0         
                      {3,0,0,0,0,0,0,4,0},  // 1
                      {0,0,0,6,0,1,0,2,0},  // 2
                      {2,0,6,0,1,0,0,0,0},  // 3
                      {0,0,0,1,0,0,0,0,8},  // 4
                      {0,0,1,0,0,0,8,0,0},  // 5
                      {0,0,0,0,0,8,0,0,0},  // 6
                      {0,4,2,0,0,0,0,0,0},  // 7
                      {4,0,0,0,8,0,0,0,0}   // 8
                     };

      Graph G = new Graph(conn);

      G.Prim();

   }
}

/*
Representation:

  LinkCost[][]:

     *  3  *  2  *  *  *  *  4                      
     3  *  *  *  *  *  *  4  * 
     *  *  *  6  *  1  *  2  * 
     2  *  6  *  1  *  *  *  * 
     *  *  *  1  *  *  *  *  8 
     *  *  1  *  *  *  8  *  * 
     *  *  *  *  *  8  *  *  * 
     *  4  2  *  *  *  *  *  * 
     4  *  *  *  8  *  *  *  * 

============================================= 

ReachSet = 0 

Min cost edge: (0,3)cost = 2
ReachSet = 0 3 

Min cost edge: (3,4)cost = 1
ReachSet = 0 3 4 

Min cost edge: (0,1)cost = 3
ReachSet = 0 1 3 4 

Min cost edge: (0,8)cost = 4
ReachSet = 0 1 3 4 8 

Min cost edge: (1,7)cost = 4
ReachSet = 0 1 3 4 7 8 

Min cost edge: (7,2)cost = 2
ReachSet = 0 1 2 3 4 7 8 

Min cost edge: (2,5)cost = 1
ReachSet = 0 1 2 3 4 5 7 8 

Min cost edge: (5,6)cost = 8
ReachSet = 0 1 2 3 4 5 6 7 8 

========================================                           

Edges of the Min. cost spanning tree:

     0 --> 0
     0 --> 1
     7 --> 2
     0 --> 3
     3 --> 4
     2 --> 5
     5 --> 6
     1 --> 7
     0 --> 8

***/
